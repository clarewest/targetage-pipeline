---
title: "Colocalisation/overlap analysis for age-related diseases (ARDs)"
output: html_document
---

```{r setup, include=FALSE}
library(tidyverse)
library(arrow)
library(data.table)  # got some giant dataframes
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE)

```

### Colocalisation/overlap analysis for age-related diseases (ARDs)

I got this data using the Open Targets Platform and Genetics data downloads and PySpark by doing the following:

1. Get all the targets with genetic association with the ARDs
2. Get all the GWAS studies contributing to that evidence
3. Get all *lead* variants from those GWAS studies
4. For these variants, get all colocalisation signals with h4>=0.8 and pval< 5e-8 (`coloc`)
5. For these variants, get all overlapping variants (`overlap`)


#### Data 

In OT Platform, they use `n_initial` from OT Genetics as the `studySampleSize`, so that's what I'll use. 

```{r}
min_n_cases = 2000    ## min n cases for case control studies
min_n_initial = 2000  ## min sample size for continuous traits

### All lead variant data for ARDs
ard_leads_all <- arrow::read_parquet("data/targetage/ard_leads.parquet/part-00000-a28f4864-1968-4929-9e4b-99b6f6c25ec5-c000.snappy.parquet")
ard_leads <- filter(ard_leads_all, (n_cases >= min_n_cases) | (is.na(n_cases) & n_initial >= min_n_cases))
#save(ard_leads, file = "ard_leads_filtered.Rda")

### Colocalisation data 
coloc <- arrow::read_parquet("data/targetage/coloc_ard_leads.parquet/part-00000-31d4d431-a725-448d-8486-6c7ea9eeff55-c000.snappy.parquet", as_tibble=TRUE)

### Overlap data
overlap <- arrow::read_parquet("data/targetage/overlap_ard_leads.parquet/part-00000-9fd1e8a0-6c9d-43fe-ac26-f4f8c53005a6-c000.snappy.parquet",as_data_frame = TRUE)
overlap <-   overlap %>% 
  filter((n_cases >= min_n_cases) | (is.na(n_cases) & n_initial >= min_n_cases)) %>%
  filter((right_n_cases >= min_n_cases) | (is.na(right_n_cases) & right_n_initial >= min_n_cases)) %>%
  filter(!is.na(right_is_lead)) %>% ## one variant is NA for this: GCST006288 11_86942946_G_A
  as.data.table() 

## All the colocalisation where the right hand variant is the lead variant (so we have one node per associated locus)
lead_coloc <- coloc %>% filter(right_is_lead == TRUE) 

## All the colocalisation hits where the right hand study is an xQTL study, for later
qtl_coloc <- coloc %>% filter(right_type %in% c("eqtl", "pqtl"))

## All the hits within the ARDs (i.e. both studies are for ARDs)
coloc_within <- lead_coloc %>% filter(!is.na(right_morbidity)) %>% 
  filter((n_cases >= min_n_cases) | (is.na(n_cases) & n_initial >= min_n_cases)) %>%
    filter((right_n_cases >= min_n_cases) | (is.na(right_n_cases) & right_n_initial >= min_n_cases))
overlap_within <- overlap[!is.na(right_morbidity)] %>% as.data.frame()

## All the hits with traits other than our ARDs of interest
coloc_without <- lead_coloc %>% filter(is.na(right_morbidity)) %>% 
  filter((n_cases >= min_n_cases) | (is.na(n_cases) & n_initial >= min_n_cases)) %>%
    filter((right_n_cases >= min_n_cases) | (is.na(right_n_cases) & right_n_initial >= min_n_cases))
overlap_without <- overlap[is.na(right_morbidity)] %>% as.data.frame()

## Overlap/LD where both have sumstats
overlap_within_sumstats <- overlap_within %>% filter(has_sumstats == TRUE & right_has_sumstats == TRUE)
overlap_within_nosumstats <- overlap_within %>% filter(has_sumstats == FALSE | right_has_sumstats == FALSE)

```

#### Some background 

The list of ARDs, number of GWAS studies, and number of (lead) variants;

```{r echo=FALSE}
ard_leads %>% group_by(morbidity, studyId) %>% summarise(n_variants = length(studyId)) %>% ungroup() %>% group_by(morbidity) %>% summarise(n_gwas_studies = length(morbidity), n_variants = sum(n_variants)) %>% knitr::kable()

```

The vast majority of studies don't have summary statistics:

```{r, echo = FALSE}
ard_leads_all %>% select(morbidity, studyId, has_sumstats) %>% group_by(morbidity) %>% mutate(n=length(unique(studyId))) %>% unique() %>% ggplot(., aes(y=reorder(morbidity, n))) + geom_bar(aes(fill=has_sumstats)) + theme_bw() + labs(x="Number of GWAS studies") + geom_text(data = . %>% select(morbidity, n) %>% unique(), aes(label = n, x = n), hjust = 0, nudge_x = 5) + theme(panel.grid.minor = element_blank(), panel.grid.major.y = element_blank(), axis.title.y = element_blank())
```

How many studies are we excluding:

```{r, echo = FALSE}

ard_leads_all %>% 
  select(studyId, morbidity, n_cases) %>% 
  unique() %>% 
  group_by(morbidity) %>% 
  mutate(max = max(n_cases, na.rm = TRUE)) %>% 
  ggplot(., aes(x =n_cases, y = reorder(morbidity, max))) + 
    geom_vline(xintercept = 2000, colour = "orange") + 
    geom_boxplot() + 
    theme_bw() + 
    theme(panel.grid.major.y = element_blank(),
          axis.title.y = element_blank())

ard_leads_all %>% 
  select(studyId, morbidity, n_cases) %>% 
  unique() %>% 
  ggplot(., aes(y = morbidity, fill = n_cases >= 2000)) + 
  geom_bar() + 
  theme_bw() + 
  theme(panel.grid.minor = element_blank(),
        panel.grid.major.y = element_blank(),
        axis.title.y = element_blank())

```

TODO: Should we use a tag variant number or jaccard index cutoff?

What is the distribution of overlapping variants?

Some leads have > 1000 tagged variants with only a small fraction overlapping

Eg https://genetics.opentargets.org/study/GCST007091 17_45961419_A_G (LD set size according to the portal is 3075, here it is 3146)

```{r}

tags <- overlap %>% 
  select(morbidity, LR_overlap, lead_distinct, right_distinct) %>% 
  mutate(lead_total = lead_distinct + LR_overlap,
         right_total = right_distinct + LR_overlap,
         jaccard = LR_overlap / (lead_distinct + right_distinct + LR_overlap)) 

tags %>% 
    select(-lead_distinct, -right_distinct) %>% 
     pivot_longer(-morbidity) %>%
     ggplot(., aes(x = value)) + geom_density() + facet_wrap(~name, scales = "free") + theme_bw()



sapply(tags, summary)
  
```

TODO: Can we determine how much extra information colocalisation gives us compared to overlap, when we have full summary statistics? I.e. does it add any or discard any that we would have considered overlapping anyway?

```{r}

coloc <- g_all$coloc_edges
ld <- g_all$edges
ss_studies <- ard_leads %>% mutate(studyId = paste0(studyId, ".", lead_variantId)) %>% select(studyId, has_sumstats) %>% unique()
ldj <- ld %>% left_join(ss_studies %>% select(from = studyId, from_has_sumstats = has_sumstats)) %>% left_join(ss_studies %>% select(to = studyId, to_has_sumstats = has_sumstats))
colocj <- coloc %>% left_join(ss_studies %>% select(from = studyId, from_has_sumstats = has_sumstats)) %>% left_join(ss_studies %>% select(to = studyId, to_has_sumstats = has_sumstats))
ld_ss <- ldj %>% select(-color, -from_has_sumstats, -to_has_sumstats) %>% mutate(LD = TRUE)
coloc_ss <- colocj %>% select(-color, -from_has_sumstats, -to_has_sumstats) %>% mutate(coloc_ss = TRUE)
tmp <- full_join(coloc_ss, ld_ss)
tmp %>% count(morbidity, coloc_ss, LD) %>% View()
tmp %>% count(coloc_ss, LD)

```

#### Graphs 

Make a graph to visualise the variants and to determine the number of independent genetic signals (i.e. number of disconnected communities) for each ARD. Then we can determine the extent of overlap between ARDs - how many signals are shared compared to the total number of signals. 


```{r}
library(visNetwork)
library(igraph)

## Just to get nice colours
gg_color_hue <- function(n) {
  hues = seq(15, 375, length = n + 1)
  hcl(h = hues, l = 65, c = 100)[1:n]
}

## Makes the graph for a given ARD(s)
gwas_graph <- function(curr_morbidities,curr_variants,curr_coloc,curr_overlap, plot = TRUE) {
  
  g <- list()
  
  # Different colours for ARDs
  g$colours <-
    data.frame(color = gg_color_hue(length(curr_morbidities)), morbidity = curr_morbidities)
  # Get variants and overlaps just for the ARD(s) of interest
  m_variants <- curr_variants %>% filter(morbidity %in% curr_morbidities)
  m_overlap <-
    curr_overlap %>% filter(morbidity %in% curr_morbidities &
                         right_morbidity %in% curr_morbidities)
  m_coloc <-
    curr_coloc %>% filter(morbidity %in% curr_morbidities &
                       right_morbidity %in% curr_morbidities)
  
  # Edges: where two studyId+variantId have at least one overlapping tag variant
  g$edges <-
    m_overlap %>%
    mutate(
      from = paste(studyId, lead_variantId, sep = "."),
      to = paste(right_studyId, right_variantId, sep = ".")
    ) %>%
    filter(from != to) %>%
    mutate(dashes = ifelse(has_sumstats == TRUE & right_has_sumstats, TRUE, FALSE)) %>%
    select(from, to, morbidity, dashes) %>%
    left_join(g$colours, by = "morbidity") 
  

  # Edges: where two studyId+variantId are colocalised (edges in black)
  g$coloc_edges <-
    m_coloc %>%
    mutate(
      from = paste(studyId, lead_variantId, sep = "."),
      to = paste(right_studyId, right_variantId, sep = ".")
    ) %>%
    filter(from != to) %>%
    select(from, to, morbidity) %>%
    mutate(color = "black")
  
  # Each node is a studyId+variantId
  # Make a label with the variant, reported trait, and n_cases
  g$nodes <- m_variants %>%
    mutate(id = paste(studyId, lead_variantId, sep = ".")) %>%
    select(id,
           studyId,
           lead_variantId,
           morbidity,
           has_sumstats,
           n_cases,
           trait_reported,
           direction) %>%
    unique() %>%
    left_join(g$colours, by = "morbidity") %>%
    mutate(label = paste0(lead_variantId, "\n", trait_reported, " (", n_cases, ") ", direction)) %>%
    group_by(id) %>%
    mutate(n=length(morbidity)) %>% 
    mutate(morbidity = paste0(morbidity, collapse="+")) %>%
    mutate(color = ifelse(n==1, color, "black")) %>%
 #   mutate(borderDashes = ifelse(direction == "+", FALSE, TRUE)) %>% 
    slice(1) %>%
    select(-n)
  
  if (plot){
      # Make the plot
  g$plot <-
    visNetwork(
      g$nodes,
      bind_rows(g$edges, g$coloc_edges),
      main = curr_morbidities,
      height = "1000px",
      width = "100%"
    ) %>% 
    visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) %>%
    visIgraphLayout()
  }

  
  return(g)
  
}

```


Example graphs:

```{r}

graph <- gwas_graph(c("alzheimers disease", "age-related macular degeneration"), ard_leads, coloc_within, overlap_within)
graph <- gwas_graph(c("type 2 diabetes"), ard_leads, coloc_within, overlap_within)
graph <- gwas_graph(c("osteoarthritis", "chronic pain"), ard_leads, coloc_within, overlap_within)

graph

#visSave(graph$plot, "ad_md_graph.html", selfcontained = TRUE, background = "white")
graph <- gwas_graph(d[5:6], ard_leads, coloc_within, overlap_within)


```

Community detection:

```{r}

d <- ard_leads$morbidity %>% unique()

count_communities <- function(curr_morbidities, ...){
  ## get relevant edges and nodes
  g <- gwas_graph(curr_morbidities, ...)
  if (nrow(g$edges)>0){
    ## make an igraph object
    g$ig <- graph_from_data_frame(g$edges, directed = FALSE)
    ## get clusters
    clusters <- clusters(g$ig)
    V(g$ig)$cluster <- clusters$membership
    ## add cluster ID, cluster size, and n_morbidities to nodes dataframe
    n <- get.data.frame(g$ig, what="vertices")
    g$cn <- g$nodes %>% 
      left_join(n, by = c("id" = "name")) %>% 
      group_by(cluster) %>% 
      mutate(c_size = ifelse(is.na(cluster), NA, length(id)),
            n_morbidities = length(unique(morbidity)))
    g$clusters <- g$cn %>% group_by(cluster, n_morbidities, morbidity) %>% count() %>% pivot_wider(names_from = "morbidity", values_from = n)
    if (length(curr_morbidities) == 2){
      ## remove nodes with both morbidity
      ## get number of nodes for each morbidity in each cluster
      tmp <- g$cn %>% filter(str_detect(morbidity, "\\+", negate = TRUE)) %>% group_by(cluster, n_morbidities, morbidity) %>% count()
      ## how many nodes aren't in a cluster i.e. don't overlap with any other nodes (i.e. unreplicated) for each morbidity
      singles <- tmp %>% ungroup() %>% filter(is.na(cluster)) %>% select(morbidity, single = n)
      ## for clusters, how many consist of just one morbidity (distinct) and how many contain both (shared)
      shared <- tmp %>% 
        filter(!is.na(cluster)) %>% # remove single nodes (accounted for in `singles` above)
        select(-n) %>% 
        mutate(n_morbidities = ifelse(n_morbidities > 1, 2, n_morbidities)) %>% # clusters with more than 2 morbidities include nodes from GWAS studies involving both morbidity A and B together, so treat these as 2 (i.e. `shared`)
        group_by(morbidity, n_morbidities) %>% 
        count() %>% 
        mutate(n_morbidities = recode(n_morbidities, `1` = "distinct", `2` = "shared")) %>% pivot_wider(names_from = n_morbidities, values_from = n) %>%  
        full_join(singles) 
      if (nrow(shared)==0){
          shared <- data.frame(morbidity = curr_morbidities) %>% mutate(distinct = 0, shared = 0) %>% left_join(singles)
      }
      g$overlap <- shared %>% 
        ungroup() %>% 
        rename(morbidity_A = morbidity) %>% 
        mutate(morbidity_B = rev(.$morbidity_A)) %>%
        inner_join(shared %>% rename(morbidity_B = morbidity), by = "morbidity_B", suffix = c("_A", "_B"))
    }
  } else {
      if (length(curr_morbidities) == 2){
        singles <- g$nodes %>% group_by(morbidity) %>% count(name = "single")
        shared <- data.frame(morbidity = curr_morbidities) %>% mutate(distinct = 0, shared = 0) %>% left_join(singles)
        g$overlap <- shared %>% 
          rename(morbidity_A = morbidity) %>% 
          mutate(morbidity_B = rev(.$morbidity_A)) %>%
          inner_join(shared %>% rename(morbidity_B = morbidity), by = "morbidity_B", suffix = c("_A", "_B"))
      }
  }
  return(g)
}

g_all <- count_communities(d, ard_leads, coloc_within, overlap_within, plot = FALSE)

```

There are `length(unique(g_all$cn$cluster))` clusters, and `sum(is.na(g_all$cn$cluster))` nodes are not in a cluster (i.e. not replicated in another study). 

`length(unique(filter(g_all$cn, n_morbidities>1)$cluster))` clusters involve more than one morbidity.

Largest cluster has `max(g_all$cn$c_size, na.rm = TRUE)` nodes and includes `unique(filter(g_all$cn, c_size == max(g_all$cn$c_size, na.rm = TRUE))$morbidity)`

How many nodes are in each cluster, and how many morbidities?

```{r}
cluster_attributes <- g_all$cn %>% filter(!is.na(cluster)) %>% select(cluster, c_size, n_morbidities) %>% unique() %>% pivot_longer(-cluster, names_to = "attribute", values_to = "n") 

ggplot(cluster_attributes, aes(x=n, fill = attribute)) + geom_histogram(binwidth = 1) + facet_wrap(~attribute, nrow = 2, scales = "free") + theme_bw() + guides(fill = FALSE)

ggplot(cluster_attributes, aes(x=n)) + geom_boxplot() + facet_wrap(~attribute, nrow = 2, scales = "free_x") + theme_bw() + guides(fill = FALSE)

g_all$cn %>% filter(!is.na(cluster)) %>% select(cluster, c_size, n_morbidities) %>% unique() %>% ggplot(., aes(x=c_size, y=n_morbidities)) + geom_point(alpha=0.7) + theme_bw()

g_all$clusters 
```

Looking pairwise between diseases:

```{r}

mm_g <- count_communities(c("alzheimers disease", "age-related macular degeneration"), ard_leads, coloc_within, overlap_within, plot = FALSE)
mm_g$cn %>% group_by(cluster, n_morbidities, morbidity) %>% count() %>% ggplot(., aes(x=reorder(as.character(cluster), n), y = n, fill = morbidity)) + geom_col(position = "stack") + theme_bw() + labs(x="Cluster", y = "Number of study+variants")
mm_g$overlap

combs <- combn(d, 2, simplify = FALSE)
pairwise_graphs <- list()
for (i in seq_along(combs)){
  pairwise_graphs[[i]] <- count_communities(combs[[i]], ard_leads, coloc_within, overlap_within, plot = FALSE)
}

overlaps <- pairwise_graphs %>% purrr::map("overlap")

overlaps_df <- pairwise_graphs %>% purrr::map(8) %>% dplyr::bind_rows()
```

Now to make a heatmap

```{r}

textcol <- "grey40"

prop_shared <- overlaps_df %>% mutate(total_A = distinct_A+shared_A+single_A, proportion_A = shared_A/total_A) %>% select(morbidity_A, morbidity_B, total_A, shared_A, proportion_A)

### making a heatmap
coloc_pre_heatmap <- prop_shared %>% select(-shared_A, -total_A) %>% pivot_wider(names_from = morbidity_A, values_from = proportion_A) %>%  replace(is.na(.), 0)

library("ggdendro")

# Run clustering
coloc_mat <- as.matrix(coloc_pre_heatmap[,-1])
rownames(coloc_mat) <- coloc_pre_heatmap$morbidity.y
coloc.dendro <- as.dendrogram(hclust(d = dist(x = coloc_mat)))

# Create dendro
dendro.plot <- ggdendrogram(data = coloc.dendro, rotate = TRUE)

# Preview the plot
print(dendro.plot)

## reorder to the clustered order
coloc.order <- order.dendrogram(coloc.dendro)
                                                                                                                                                                                                                                                                                                                                      
coloc_pre_heatmap_long <- coloc_pre_heatmap %>% 
  replace(. == 0, NA) %>%
  pivot_longer(-morbidity_B, names_to = "morbidity_A", values_to = "proportion") %>%
  left_join(prop_shared %>% 
              select(-proportion_A), 
              by = c("morbidity_A", "morbidity_B")) %>%
  replace(. == "chronic obstructive pulmonary disease", "COPD")


coloc_pre_heatmap_long$morbidity_B <- factor(x = coloc_pre_heatmap_long$morbidity_B,
                                        levels = coloc_pre_heatmap$morbidity_B[coloc.order],
                                        ordered = TRUE)
coloc_pre_heatmap_long$morbidity_A <- factor(x = coloc_pre_heatmap_long$morbidity_A,
                                        levels = coloc_pre_heatmap$morbidity_B[coloc.order],
                                        ordered = TRUE)

coloc_heatmap <- coloc_pre_heatmap_long %>%
  ggplot(., aes(x=morbidity_A, y = morbidity_B, fill = proportion)) +
  geom_tile(colour = textcol) +
  geom_text(aes(label = shared_A), size = 2.1) + 
  labs(subtitle = "Proportion of independent genetic associations for ARD X that are\ncolocalised with at least one hit variant from ARD Y") +
  coord_fixed() +
  theme_bw(base_size = 10) +
  scale_y_discrete(expand = c(0, 0)) +
  scale_x_discrete(expand = c(0, 0)) +
  scale_fill_gradient(
    "proportion",
    low = "#CBDEF0",
    high = "#08306B",
    na.value = "white",
    guide = guide_colorbar(frame.colour = "black", frame.linewidth = 0.8)
  ) +
  theme(
    axis.text.x = element_text(
      colour = textcol,
      angle = 45,
      hjust = 1
    ),
    axis.text.y = element_text(vjust = 0.2,
                               colour = textcol),
    axis.ticks = element_line(size = 0.4),
    axis.title = element_blank(),
    plot.background = element_blank(),
    plot.margin = margin(0.7, 0.4, 0.1, 0.2, "cm"),
    plot.title = element_text(
      colour = textcol,
      hjust = 0,
      size = 14,
      face = "bold"
    ),
    panel.border = element_rect(colour = "black",
                                size = 0.8)
  )


ggsave(coloc_heatmap, file = "coloc_heatmap.png", width = 6, height = 6, dpi = 300)


```


```{r}
## all nodes that are in a cluster
clustered_nodes <- g_all$cn %>% filter(!is.na(cluster))

## nodes in a cluster that includes more than one morbidity
mm_clustered_nodes <- clustered_nodes %>% filter(n_morbidities>1)

view_cluster <- function(nodes, g, curr_cluster){
  cluster_nodes <- nodes %>% filter(cluster %in% curr_cluster)
  cluster_edges <- g$edges %>% 
  filter(from %in% cluster_nodes$id) %>%
  filter(to %in% cluster_nodes$id)
  vn <- 
    visNetwork(
      cluster_nodes,
      cluster_edges,
      height = "1000px",
      width = "100%"
    ) %>% 
#    visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) %>%
    visIgraphLayout()
  return(vn)
}

view_morbidity <- function(nodes, g, curr_morbidity){
  cluster_nodes <- nodes %>% 
    filter(cluster %in% filter(nodes, morbidity==curr_morbidity)$cluster)
  cluster_edges <- g$edges %>% 
  filter(from %in% cluster_nodes$id) %>%
  filter(to %in% cluster_nodes$id)
  vn <- 
    visNetwork(
      cluster_nodes,
      cluster_edges,
      height = "1000px",
      width = "100%"
    ) %>% 
#    visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) %>%
    visIgraphLayout()
  return(vn)
}
  
```

```{r}
library(UpSetR)
mm_mat <- mm_clusters %>% select(cluster, morbidity, n)  %>% pivot_wider(names_from = morbidity, values_from = n, values_fill = list(n=0)) %>% data.frame()

mm_mat2 <- as.matrix(mm_mat[,-1])
rownames(mm_mat2) <- mm_mat$cluster

upset(mm_mat)

mat <- cn %>% filter(!is.na(cluster)) %>% ungroup() %>% select(cluster, morbidity) %>% group_by(cluster, morbidity) %>% count() %>% pivot_wider(names_from = morbidity, values_from = n)
mat[is.na(mat)] <- 0

tmat <- cn %>% filter(!is.na(cluster)) %>% ungroup() %>% select(cluster, morbidity) %>% group_by(cluster, morbidity) %>% count()


cmat <- as.matrix(mat[,-1])
rownames(cmat) <- mat$cluster

```

```{r}
#save(g_all, file = "graph_all_morbidities.Rda")
load("graph_all_morbidities.Rda")

```


Now to link to genes

Q1: Do we use L2G or V2G?
Q2: How do we expand to tag variants? Tag variants depend on the study if using finemapping
```{r}
# studies + variants
studies_variants <- g_all$cn %>% filter(n_morbidities > 1) %>% ungroup() %>% select(studyId, lead_variantId) %>% unique()

if(0) {
library(ghql)
library(jsonlite)

initialise_api <- function(){
  cli <- GraphqlClient$new(
  url = "https://genetics-api.opentargets.io/graphql"
)
  return(cli)
}

initialise_queries <- function(){
    qry <- Query$new()
  qry$query('l2g_query', 'query l2gQuery($studyId: String!, $variantId: String!){
  studyLocus2GeneTable(studyId: $studyId, variantId: $variantId){
    rows {
      gene {
        id
        symbol
      }
      hasColoc
      yProbaModel
      yProbaDistance
      yProbaInteraction
      yProbaMolecularQTL
      yProbaPathogenicity
      distanceToLocus
    }
  }
}')
  return(qry)
}

## Do the API call
fetch_l2g <- function(df, variables){
  result <- fromJSON(cli$exec(qry$queries$l2g_query, variables, flatten = TRUE))$data
  l2g_result <- result$studyLocus2GeneTable %>% bind_cols(df)
  return(l2g_result)
}

#########

cli <- initialise_api()
qry <- initialise_queries()

## split the data frame into smaller chunks (1000 rows)
## I don't really know if we need to do this but just in case
## I'm scared of breaking the server with too many successive calls
n <- 1000
nr <- nrow(to_query)
studies_variants_split <-
  studies_variants %>% 
  split(., rep(1:ceiling(nr / n), each = n, length.out = nr))

# Somewhere to hold the results
l2g_all <- vector(mode = "list", length = length(studies_variants_split))

## Do the first chunk on its own to check 
l2g_all[[1]] <-  studies_variants_split[[1]]  %>% 
  group_by(studyId, lead_variantId) %>% 
  group_split() %>% 
  ## API call for each studyID + variantID
  purrr::map(~fetch_l2g(df = ., variables = list(studyId = .$studyId, variantId = .$lead_variantId))) %>%
  bind_rows() 

## Do all the other chunks
for (i in seq(2, length(l2g_all))){
  print(i)
  l2g_all[[i]] <- studies_variants_split[[i]] %>% 
    group_by(studyId, lead_variantId) %>% 
    group_split() %>% 
    ## API call for each studyID + variantID
    purrr::map(~fetch_l2g(df = ., variables = list(studyId = .$studyId, variantId = .$lead_variantId))) %>%
    bind_rows() 
    Sys.sleep(5)
}
}

#l2g_all_joined <- l2g_all %>% bind_rows() %>% jsonlite::flatten()
#save(l2g_all_joined, file="ltg_all.Rda")

load("ltg_all.Rda")

```

Only use genes with >=0.5 L2G score? Or 0.05?

"Prioritised genes" section of GWAS study page on OT genetics shows genes with >=0.5.
Open Targets Platform uses >=0.05 

492 clusters have more than one morbidity.
270 have at least one gene with coloc evidence

```{r}
min_l2g = 0.05
tbl <- g_all$cn %>% group_by(cluster, n_morbidities) %>% summarise(nodes = length(id), morbidities = paste0(unique(morbidity), collapse = ", ")) %>% arrange(-n_morbidities) %>% filter(!is.na(cluster))

cluster_genes <- g_all$cn %>% left_join(l2g_all_joined %>% filter(yProbaModel>= min_l2g)) %>% left_join(tbl) %>% filter(n_morbidities>1)
```


```{r}

top_l2g <- l2g_all_joined %>%
    group_by(studyId, lead_variantId) %>% 
    top_n(1,yProbaModel )
top_l2g %>% pivot_longer(contains("yProba")) %>% ggplot(., aes(x=value, y=name)) + geom_boxplot() + theme_bw() + theme(axis.title.y = element_blank(), axis.title.x = element_blank())

```


If we collapse each cluster to a node, we can link to genes and diseases!

```{r}
C2G_edges <- 
  cluster_genes %>% 
  filter(yM)
  select(from = cluster, to = gene.id, morbidity, hasColoc, starts_with("yProba")) %>%
  mutate(type = "L2G") %>%
  unique()

C2D_edges <- 
  cluster_genes %>%
  select(from = cluster, to = morbidity, studyId) %>%
  mutate(type = "GWAS") %>%
  unique()

C_nodes <- cluster_genes %>% select(id = cluster, morbidities, c_size) %>% unique() %>% filter(!is.na(id)) %>% mutate(id = as.character(id), type = "cluster", color = "green")
M_nodes <- cluster_genes %>% ungroup() %>% select(id = morbidity, trait_reported) %>% unique() %>% group_by(id) %>% summarise(traits = paste(trait_reported, collapse = ", ")) %>% mutate(type = "morbidity", color = "red")
G_nodes <- cluster_genes %>% ungroup() %>% select(id = gene.id, gene.symbol) %>% unique() %>% mutate(type = "gene", color = "blue")

cluster_vn <- 
  visNetwork(
    bind_rows(C_nodes, M_nodes, G_nodes),
    bind_rows(C2G_edges, C2D_edges),
    height = "1000px",
    width = "100%"
  ) %>%
    visIgraphLayout()


```